{"branch": "origin/master", "commit": "Base commit for open source releasing\n", "commitHash": "72724d710670ada6d9a46c5065f7210a90074fc5", "date": "2020-06-08 09:27:53", "diff": "@@ -0,0 +1,245 @@\n+// Copyright 2020 Booking.com\n+//\n+// Licensed under the Apache License, Version 2.0 (the \"License\");\n+// you may not use this file except in compliance with the License.\n+// You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+// Unless required by applicable law or agreed to in writing, software\n+// distributed under the License is distributed on an \"AS IS\" BASIS,\n+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+// See the License for the specific language governing permissions and\n+\n+package util\n+\n+import (\n+\t\"bytes\"\n+\t\"crypto/rand\"\n+\t\"crypto/rsa\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"math/big\"\n+\t\"os\"\n+\t\"strings\"\n+\t\"testing\"\n+\n+\t\"github.com/bookingcom/yubistack/internal\"\n+)\n+\n+const (\n+\trsaTest = `-----BEGIN RSA PRIVATE KEY-----\n+MIIEogIBAAKCAQEAqhOY9FvnDkPao59AmLDJlnPySd3FXwSXQCVzQsxpQTaTrcDH\n+G4MT4Re/wWddR6/R/U/W83DV4OITEmigFFeHOULeECeBe2WNK3X4wMqq1gjjOSKg\n+WjHc+q9GSPbPw+rU6Pw6U22omI3G/aZdg5pz6cLXsYNfN9XD60QzjnstKjY5cStO\n+L8DT0aDbdqHK6mEM92n9d/cT8ms+7QOt2ssYq2Q52KDWamrZz0lk62GhU8Q4hE5u\n+At9E3LZYk8hxvwuJ6fsFqTMeyicq2Y+Fj/+bjkREdmol8WkYvN+fH8H1UmpKE99H\n+bsa4jCuPpHOAKRnHpXAK94RYhgsy5bcDDQo9FwIDAQABAoIBAG7DLpTNmW+f3y86\n+Ur5ePBsAzeUvSg/0lHBRM3xoVZAD9C9vYfxX5EVuyxIwt/4s0gwvx+RpMtEvSo5t\n+lvtIeadgFfDdWaU8YLDSNruQAaw8w4Z9N4MmAC0+ov53xp1oPVqykWWt/+PCSbr9\n+ct93Yk/19bUEwqlBTUPV+eGr9KEM+OU15mX50C0H9BNczVql2Ma/DhH2w0mLUhV2\n+rci4P///rFuh/DAM/2V+4ZxNslcTYV8BcKmP0FB+MbS6D6SVFe5ULvJ0iacDCHsf\n+bU4hVhNS4MtqnVFCPHGuY5Sy9BWm80THyRce8WDqWJBEIyGRinSEYWZVlIcm9DHe\n+BoFnQFkCgYEA4DMCk1wovnhuNA9CQelgXFW/dqrFkObId30qJp7uzLUP5Qtm1c7x\n+PMrItfNoN197Ye/qi9xHcJ4ZkZLvlM6GLyEkEYPO4ov4+d3CpfiAsRoxTo3XFPAP\n+d78mMD56xlfbzt+dGzcvILHFlP49u8gzT/6RjTAZSWGZGLM3LWzy71MCgYEAwjNQ\n+435eEGCFSBHnEsZiGD4+mZTD7uY9oyNuSe6ZrDwBBGD8INQKeuFOCS1fW5cmROX1\n+OPpCVaStVKJbM/p6rNWgbivWIuwO0y4fuhzvYgBUyzN5kIkCXCcZdZRHWk323uRr\n+Qnt0ApgXn+JS2VTMXTA5VNB/0CEPWXP9crKxNq0CgYBepAnVTNUCOnJC1aIhkrOT\n+prrRDBukJFfBYPu3G+YwUcpo5Jw/a0EYaX26mQqIPW0nFZDMA2vA1WxzsDQke93W\n+7UV9g0eFCJNMXtl5GGKy4ByqTWPauc+9u9oSCX3oVlQ6itiWEYB6a7C9SWmj6EoI\n+3axxjjlOab2n2JdVPKV8cwKBgFsG8LBhqDem9nJMqfI7+PkCHBejCqAtXdDdJ7IR\n+3AhGa/egei3tFih4+ToGAX+N/ssmuuYFMBiywug73eIkU2I2FCfv9kSSP3SvVwHG\n+1FIsc5J3w1CDWA7X6PAbG8LxbnkVuk0ETuF0ZwZzcIAcZlp74zOlM3PcOzSj0LX1\n+mmlVAoGAJxopOvh1GPKjD+v9WvKb/K0kErozrdGajq6Cu0u3hmBRstYydTqg/Dcn\n+4unuxl9hSgZPVRRkXQLEECLr5KgxgWf2KQH6FPR+aVO3+KBgNioCVOecrwO/M4mz\n+moNeFBb2flsNipe7Swkc8/dglsMgKMnxxbHL3j03FhTd+jVr6kI=\n+-----END RSA PRIVATE KEY-----`\n+)\n+\n+//nolint:golint,gochecknoglobals\n+var rsaExp, _ = big.NewInt(0).SetString(\n+\t\"139824613569886256929565319778115395984209024274962001878614089999\"+\n+\t\t\"50512718965233544136443130587273021448939302638909517772422665754\"+\n+\t\t\"09913797909796103083260536866826834910920585263205696870442622195\"+\n+\t\t\"44005319956019660699438239692832457506017936833916378568871382423\"+\n+\t\t\"13724839686275781545184300752059524859121879924234933843092800106\"+\n+\t\t\"17304842490924322366132474881957252215514877516918248690259781080\"+\n+\t\t\"96168572715501112212349599350464445691758741514280177772440896463\"+\n+\t\t\"52158708191797180972653869440889589193288142526808188283112676783\"+\n+\t\t\"56294614280241548896898160781726948980391138493899772834927198980\"+\n+\t\t\"0946383426939323719432689631321\", 10)\n+\n+//nolint:golint,gochecknoglobals\n+// rsa.EncryptOAEP(sha256.New(), rand.Reader, &key.PublicKey, []byte(\"foo\"), []byte(\"\"))\n+var oapTest = []byte{\n+\t44, 88, 162, 86, 119, 131, 224, 92, 242, 253, 217, 107, 179, 110, 5, 141,\n+\t80, 214, 1, 238, 5, 43, 153, 53, 223, 166, 192, 247, 252, 178, 179, 14, 134,\n+\t79, 240, 168, 131, 180, 139, 222, 55, 48, 4, 45, 225, 178, 249, 152, 106,\n+\t84, 39, 89, 196, 53, 21, 122, 125, 171, 122, 190, 121, 56, 236, 141, 120,\n+\t92, 226, 171, 192, 78, 192, 54, 82, 238, 170, 157, 150, 79, 188, 34, 163,\n+\t125, 35, 248, 255, 37, 230, 180, 159, 224, 248, 127, 85, 72, 35, 137, 221,\n+\t19, 2, 79, 173, 239, 161, 95, 61, 155, 168, 199, 130, 190, 3, 29, 122, 242,\n+\t209, 9, 187, 175, 197, 34, 14, 206, 175, 168, 183, 30, 46, 94, 230, 109,\n+\t216, 82, 151, 93, 105, 135, 182, 87, 9, 193, 50, 83, 127, 194, 152, 252,\n+\t237, 107, 169, 11, 32, 92, 25, 57, 5, 83, 136, 21, 143, 51, 39, 184, 77,\n+\t55, 169, 24, 82, 206, 110, 39, 53, 78, 4, 124, 164, 38, 136, 12, 119, 163,\n+\t121, 53, 152, 254, 157, 42, 24, 38, 178, 26, 128, 6, 248, 94, 139, 10, 103,\n+\t11, 50, 173, 83, 68, 45, 142, 117, 162, 80, 211, 110, 159, 90, 103, 102,\n+\t204, 102, 10, 27, 59, 1, 89, 16, 200, 179, 66, 166, 174, 245, 88, 42, 172,\n+\t200, 73, 70, 11, 145, 92, 235, 32, 74, 1, 53, 64, 166, 227, 55, 254, 220,\n+\t39, 90, 166, 128, 202, 234, 192, 14, 252,\n+}\n+\n+//nolint:golint,gochecknoglobals\n+var entriesRSARetriever = []struct {\n+\tcypher []byte\n+\tout    []byte\n+\terr    error\n+}{\n+\t{\n+\t\toapTest, []byte(\"foo\"), nil,\n+\t},\n+\t{\n+\t\tappend(oapTest, 255), nil,\n+\t\tfmt.Errorf(\"crypto/rsa: decryption error\"),\n+\t},\n+}\n+\n+func TestDecodeRSAOAEP(t *testing.T) {\n+\tkey, err := DecodeRSAKey([]byte(rsaTest))\n+\tif err != nil {\n+\t\tt.Fatalf(\"failed to parse testing rsa key: %q\", err)\n+\t}\n+\tfor _, entry := range entriesRSARetriever {\n+\t\tout, err := DecodeRSAOAEP(key, entry.cypher)\n+\t\tif string(out) != string(entry.out) || !internal.ErrEqual(err, entry.err) {\n+\t\t\tt.Errorf(\"DecodeRSAOAEP(%s, %q) want: %q, %s - got: %q, %s\",\n+\t\t\t\tinternal.TestRSA(key), entry.cypher[:10],\n+\t\t\t\tentry.out, internal.TestError(entry.err),\n+\t\t\t\tout, internal.TestError(err))\n+\t\t}\n+\t}\n+}\n+\n+//nolint:golint,gochecknoglobals\n+var entriesReadRSAKey = []struct {\n+\tfile func(*testing.T, func(string)) error\n+\tkey  *rsa.PrivateKey\n+\terr  error\n+}{\n+\t{func(_ *testing.T, cb func(string)) error {\n+\t\tcb(\"/foo/bar\")\n+\t\treturn nil\n+\t}, nil,\n+\t\tfmt.Errorf(\"open /foo/bar: no such file or directory\")},\n+\t{\n+\t\tfunc(t *testing.T, cb func(string)) error {\n+\t\t\treturn internal.TempFile(t, func(f *os.File) error {\n+\t\t\t\tcb(f.Name())\n+\t\t\t\treturn nil\n+\t\t\t})\n+\t\t}, nil, ErrPEMDecode,\n+\t},\n+\t{\n+\t\tfunc(t *testing.T, cb func(string)) error {\n+\t\t\treturn internal.TempFile(t, func(f *os.File) error {\n+\t\t\t\tkey := `-----BEGIN RSA PRIVATE KEY-----\n+MIIEogIBAAKCAQEAqhOY9FvnDkPao59AmLDJlnPySd3FXwSXQCVzQsxpQTaTrcDH\n+-----END RSA PRIVATE KEY-----`\n+\t\t\t\tif _, err := f.Write([]byte(key)); err != nil {\n+\t\t\t\t\treturn err\n+\t\t\t\t}\n+\t\t\t\tcb(f.Name())\n+\t\t\t\treturn nil\n+\t\t\t})\n+\t\t}, nil, fmt.Errorf(\"asn1: syntax error: data truncated\"),\n+\t},\n+\t{\n+\t\tfunc(t *testing.T, cb func(string)) error {\n+\t\t\treturn internal.TempFile(t, func(f *os.File) error {\n+\t\t\t\tif _, err := f.Write([]byte(rsaTest)); err != nil {\n+\t\t\t\t\treturn err\n+\t\t\t\t}\n+\t\t\t\tcb(f.Name())\n+\t\t\t\treturn nil\n+\t\t\t})\n+\t\t}, &rsa.PrivateKey{D: rsaExp}, nil,\n+\t},\n+}\n+\n+func TestReadRSAKey(t *testing.T) {\n+\tfor _, entry := range entriesReadRSAKey {\n+\t\terr := entry.file(t, func(path string) {\n+\t\t\tkey, err := ReadRSAKeyFromFile(path)\n+\t\t\tif !internal.RSAEqual(key, entry.key) || !internal.ErrEqual(err, entry.err) {\n+\t\t\t\tt.Errorf(\"ReadRSAKeyFromFile(%q) => want: %s, %s - got: %s, %s\", path,\n+\t\t\t\t\tinternal.TestRSA(entry.key), internal.TestError(entry.err),\n+\t\t\t\t\tinternal.TestRSA(key), internal.TestError(err),\n+\t\t\t\t)\n+\t\t\t}\n+\t\t})\n+\t\tif err != nil {\n+\t\t\tt.Fatalf(\"failed to create temp file\")\n+\t\t}\n+\t}\n+}\n+\n+// Generated using\n+// echo -n \"foo\"  | openssl dgst -sha256 -hmac \"bar\" -binary | base64\n+//nolint:golint,gochecknoglobals\n+var entriesIsSignValid = []struct {\n+\thash, cypher string\n+\tkey          []byte\n+\tout          bool\n+}{\n+\t{\n+\t\t\"FHkzIYqqvAuLEKKzpcNGhMjZQ0G88QpHNtxycPd0GFE=\", \"foo\", []byte(\"bar\"), true,\n+\t},\n+\t{\n+\t\tSignEncodeBase64([]byte(\"foo\"), []byte(\"bar\")), \"foo\",\n+\t\t[]byte(\"bar\"), true,\n+\t},\n+\t{\n+\t\t\"FHkzIYqqvAuLEKKzpcNGhMjZQ0G88QpHNtxycPd0GFE=\", \"bar\", []byte(\"bar\"), false,\n+\t},\n+\t{\n+\t\tSignEncodeBase64([]byte(\"foo\"), []byte(\"bar\")), \"bar\",\n+\t\t[]byte(\"bar\"), false,\n+\t},\n+}\n+\n+func TestIsSignValid(t *testing.T) {\n+\tfor _, entry := range entriesIsSignValid {\n+\t\tout := IsSignValid(entry.hash, entry.cypher, entry.key)\n+\t\tif entry.out != out {\n+\t\t\tt.Errorf(\"IsSignValid(%q, %q, %q) => want: %t - got: %t\",\n+\t\t\t\tentry.hash, entry.cypher, entry.key, entry.out, out)\n+\t\t}\n+\t}\n+}\n+\n+//nolint:golint,gochecknoglobals\n+var entriesRandString = []struct {\n+\treader io.Reader\n+\tsize   int\n+\tout    string\n+\terr    error\n+}{\n+\t{strings.NewReader(\"foo\"), 3, \"Zm9v\", nil},\n+\t{strings.NewReader(\"foo\"), 6, \"Zm9vAAAA\", io.ErrUnexpectedEOF},\n+}\n+\n+func TestRandString(t *testing.T) {\n+\tdefer func() { reader = rand.Reader }() // ensure that we don't alter further tests\n+\tfor _, entry := range entriesRandString {\n+\t\tbuf := bytes.NewBuffer(nil)\n+\t\treader = io.TeeReader(entry.reader, buf)\n+\t\tout, err := Nonce(entry.size)\n+\t\tif out != entry.out || !internal.ErrEqual(err, entry.err) {\n+\t\t\tt.Errorf(\"Nonce(%d) with %q => want: %q, %s - got: %q, %s\",\n+\t\t\t\tentry.size, buf.String(),\n+\t\t\t\tentry.out, internal.TestError(entry.err), out, internal.TestError(err))\n+\t\t}\n+\t}\n+}\n", "path": "pkg/util/crypt_test.go", "printDiff": "\u001b[93m-----BEGIN RSA PRIVATE KEY-----\u001b[0m", "reason": "RSA-PK", "stringsFound": ["-----BEGIN RSA PRIVATE KEY-----", "-----BEGIN RSA PRIVATE KEY-----"]}
